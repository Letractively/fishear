package net.fishear.web.t5.base;

import java.lang.reflect.ParameterizedType;

import net.fishear.data.generic.entities.EntityI;
import net.fishear.data.generic.query.QueryConstraints;
import net.fishear.data.generic.query.conditions.Conditions;
import net.fishear.data.generic.services.ServiceI;
import net.fishear.exceptions.AppException;
import net.fishear.utils.Classes;
import net.fishear.web.t5.data.PagingDataSource;
import net.fishear.web.t5.internal.SearchFormI;
import net.fishear.web.t5.internal.SearchableI;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public abstract class
	GenericGrid<T extends EntityI<?>> 
extends 
	ComponentBase
implements
	SearchableI<T>
{

	Logger log = LoggerFactory.getLogger(getClass());

	private Class<T> entityType;

	protected T row;

	private SearchFormI<T> searchComponent;

	/**
	 * @return the service that manages entities for this 
	 */
	public abstract ServiceI<T> getService();

	/**
	 * method suit for modifying conditions. 
	 * 
	 * @param cond conditions either generated by search component (in case it exists in from), or empry conditions.
	 */
	protected void modifyConditions(Conditions cond) {
		
	}

	/**
	 * @return data source
	 */
	public PagingDataSource getDataSource() {
		PagingDataSource pds = new PagingDataSource(getService());
		if(searchComponent != null) {
			Conditions cond = searchComponent.getSearchConstraints();
			Conditions cond2 = cond == null ? new Conditions() : cond;
			modifyConditions(cond2);
			pds.setConditions(cond2.isEmpty() ? cond : cond2);
		} else {
			Conditions cond = new Conditions();
			modifyConditions(cond);
			if(!cond.isEmpty()) {
				pds.setConditions(cond);
			}
		}
		modifyConstraints(pds.getQueryConstraint());
		return pds;
	}

	/**
	 * <strong>USE WITH CARE</strong> - designed to allow change complete query constraints before it is used for data get.
	 * Be aware that change of some part of it may cause application is broken. 
	 * 
	 * @param queryConstraint
	 */
	protected void modifyConstraints(QueryConstraints queryConstraint) {

	}

	@Override
	public void setSearchComponent(SearchFormI<T> searchComponent) {
		if(!searchComponent.getEntityType().isAssignableFrom(getEntityType())) {
			throw new IllegalStateException(String.format(
				"Both '%s' and '%s' (included inti it) must implement the same entity, but they does not. " +
				"'%s' implements '%s' and '%s' implements '%s'", 
					Classes.getShortClassName(this), Classes.getShortClassName(SearchFormI.class),
					getClass().getName(), getEntityType().getName(),
					searchComponent.getClass().getName(), searchComponent.getEntityType().getName()
			));
		}
		this.searchComponent = searchComponent;
	}

	@Override
	public SearchFormI<T> getSearchComponent() {
		return searchComponent;
	}

	/**
	 * @return the row
	 */
	public T getRow() {
		return row;
	}

	/**
	 * @param row the row to set
	 */
	public void setRow(T row) {
		this.row = row;
	}
	
	public Class<T> getEntityType() {
		if(entityType == null) {
			entityType = findType();
		}
		return entityType;
	}

	@SuppressWarnings("unchecked")
	private Class<T> findType() {
		Class<?> clazz = this.getClass();
		while(clazz != Object.class) {
			Object gscl = clazz.getGenericSuperclass();
			if(ParameterizedType.class.isAssignableFrom(gscl.getClass())) {
				ParameterizedType pt = (ParameterizedType)gscl;
				Object[] oa = pt.getActualTypeArguments();
				if(oa != null && oa.length > 0) {
					return (Class<T>)oa[0];
				}
			}
			clazz = clazz.getSuperclass();
		}
		throw new AppException("Subclass does not parametrize generic superclass.");
	}
}
